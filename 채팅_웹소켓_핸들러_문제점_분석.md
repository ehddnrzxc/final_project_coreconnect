# 채팅 웹소켓 핸들러 문제점 분석 및 개선 방안

## 1. 브라우저 환경·프론트 patch 문제 (messages 배열 merge/race condition)

### 발견된 문제점

#### 문제 1-1: Race Condition 가능성
**위치**: `ChatLayout.jsx`의 `handleNewMessage` 함수
- `setMessages` 내부에서는 `prev`를 사용하여 불변성을 보장하고 있음
- 하지만 외부에서 `messages.length`를 참조하는 경우가 있음 (예: 로그 출력)
- 이로 인해 클로저 문제로 인한 오래된 상태 참조 가능성

**코드 예시**:
```javascript
// ❌ 문제: messages를 직접 참조 (클로저 문제)
console.log("현재messages배열길이: messages.length", messages.length);

// ✅ 해결: setMessages 내부에서 prev 사용
setMessages((prev) => {
  console.log("prev배열길이: prev.length", prev.length);
  // ...
});
```

#### 문제 1-2: UNREAD_COUNT_UPDATE 처리 시 메시지 미로드 문제
**위치**: `ChatLayout.jsx`의 `handleNewMessage` 함수 (191-334줄)
- `UNREAD_COUNT_UPDATE` 메시지가 도착했을 때 해당 메시지가 아직 로드되지 않은 경우 `return prev`로 처리
- 이후 메시지가 로드되어도 `unreadCount`가 업데이트되지 않음

**코드 예시**:
```javascript
// ❌ 문제: 메시지를 찾지 못하면 업데이트 안 함
if (!targetMessage) {
  console.warn("메시지를 찾을 수 없음");
  return prev; // 메시지가 나중에 로드되어도 업데이트 안 됨
}
```

### 개선 방안

#### 개선 1-1: UNREAD_COUNT_UPDATE 대기 큐 추가
- 아직 로드되지 않은 메시지의 `unreadCount` 업데이트를 저장하는 큐 추가
- 메시지가 로드될 때 큐에서 해당 업데이트를 적용

```javascript
// ⭐ 개선: UNREAD_COUNT_UPDATE 대기 큐
const pendingUnreadCountUpdatesRef = useRef(new Map()); // chatId -> unreadCount

// UNREAD_COUNT_UPDATE 처리 시
if (!targetMessage) {
  // 메시지가 아직 로드되지 않았으면 큐에 저장
  pendingUnreadCountUpdatesRef.current.set(Number(chatId), Number(unreadCount));
  return prev;
}

// 메시지 로드 시 큐에서 업데이트 적용
useEffect(() => {
  if (messages.length > 0 && pendingUnreadCountUpdatesRef.current.size > 0) {
    setMessages((prev) => {
      const updated = prev.map((m) => {
        const chatId = Number(m.id);
        const pendingUpdate = pendingUnreadCountUpdatesRef.current.get(chatId);
        if (pendingUpdate !== undefined) {
          pendingUnreadCountUpdatesRef.current.delete(chatId);
          return { ...m, unreadCount: pendingUpdate };
        }
        return m;
      });
      return updated;
    });
  }
}, [messages]);
```

---

## 2. 프론트에서 UNREAD_COUNT_UPDATE 처리 로직 누락

### 발견된 문제점

#### 문제 2-1: 메시지 미로드 시 업데이트 누락
**위치**: `ChatLayout.jsx`의 `handleNewMessage` 함수 (258-268줄)
- `UNREAD_COUNT_UPDATE` 메시지가 도착했을 때 해당 메시지가 아직 로드되지 않은 경우 업데이트가 누락됨
- 메시지가 나중에 로드되어도 `unreadCount`가 업데이트되지 않음

#### 문제 2-2: 채팅방 변경 시 대기 중인 업데이트 초기화 필요
**위치**: `ChatLayout.jsx`의 `useEffect` (selectedRoomId 변경 시)
- 채팅방이 변경될 때 이전 방의 대기 중인 업데이트를 초기화해야 함
- 현재는 `processedMessageIdsRef`만 초기화하고 있음

### 개선 방안

#### 개선 2-1: UNREAD_COUNT_UPDATE 대기 큐 구현
- 위의 "개선 1-1"과 동일한 방식으로 구현

#### 개선 2-2: 채팅방 변경 시 큐 초기화
```javascript
// 채팅방 변경 시 대기 중인 업데이트 초기화
useEffect(() => {
  // ...
  processedMessageIdsRef.current.clear();
  processingMessageIdsRef.current.clear();
  pendingUnreadCountUpdatesRef.current.clear(); // ⭐ 추가
}, [selectedRoomId]);
```

---

## 3. WebSocket/STOMP subscribe 중복 또는 누락

### 발견된 문제점

#### 문제 3-1: disconnectStomp와 connectStomp 사이의 타이밍 이슈
**위치**: `ChatLayout.jsx`의 `useEffect` (selectedRoomId 변경 시, 903줄)
- `disconnectStomp()` 호출 후 즉시 `connectStomp()` 호출
- `disconnectStomp()`가 비동기적으로 처리되므로 구독이 완전히 해제되기 전에 새 구독이 생성될 수 있음

**코드 예시**:
```javascript
// ❌ 문제: disconnectStomp가 완료되기 전에 connectStomp 호출
disconnectStomp(); // 비동기 처리
connectStomp(...); // 즉시 호출 → 구독 중복 가능성
```

#### 문제 3-2: chatSocket.js의 구독 해제 로직
**위치**: `chatSocket.js`의 `connectStomp` 함수 (71-74줄)
- `onConnect` 콜백에서 기존 구독을 해제하고 있음
- 하지만 `disconnectStomp`에서 `subscription = null`로 설정하므로, `onConnect`가 호출되기 전에 구독이 이미 null일 수 있음

**코드 예시**:
```javascript
// ❌ 문제: disconnectStomp에서 subscription을 null로 설정
disconnectStomp() {
  if (subscription) {
    subscription.unsubscribe();
  }
  subscription = null; // ⚠️ 이렇게 하면 connectStomp의 onConnect에서 체크 불가
}

// connectStomp의 onConnect에서
if (subscription) { // ⚠️ 이미 null일 수 있음
  subscription.unsubscribe();
}
```

#### 문제 3-3: stompClient.deactivate() 호출 시점 문제
**위치**: `chatSocket.js`의 `connectStomp` 함수 (31-34줄)
- 기존 `stompClient`가 있으면 `deactivate()` 호출
- 하지만 `deactivate()`는 비동기적으로 처리되므로, 새 클라이언트 생성 전에 완료되지 않을 수 있음

### 개선 방안

#### 개선 3-1: disconnectStomp를 Promise로 변경
```javascript
// chatSocket.js
export function disconnectStomp() {
  return new Promise((resolve) => {
    console.log('🔥 [ChatSocket] disconnectStomp 호출');
    try {
      if (subscription) {
        console.log('🔥 [ChatSocket] 구독 해제');
        subscription.unsubscribe();
        subscription = null;
      }
      if (stompClient) {
        console.log('🔥 [ChatSocket] STOMP 클라이언트 연결 해제');
        stompClient.deactivate();
        // deactivate 완료 대기
        setTimeout(() => {
          stompClient = null;
          resolve();
        }, 100);
      } else {
        resolve();
      }
    } catch (e) {
      console.error('🔥 [ChatSocket] disconnectStomp 예외:', e);
      resolve(); // 에러가 나도 계속 진행
    }
  });
}

// ChatLayout.jsx
useEffect(() => {
  // ...
  disconnectStomp().then(() => {
    connectStomp(...);
  });
}, [selectedRoomId]);
```

#### 개선 3-2: 구독 해제 로직 개선
```javascript
// chatSocket.js의 connectStomp에서
onConnect: () => {
  // ⭐ 기존 구독 해제 (안전하게)
  if (subscription && subscription.id) {
    try {
      subscription.unsubscribe();
    } catch (e) {
      console.warn('구독 해제 실패:', e);
    }
  }
  subscription = null; // ⭐ 명시적으로 null 설정
  
  // 새 구독 생성
  subscription = stompClient.subscribe(...);
}
```

#### 개선 3-3: stompClient 재사용 방지
```javascript
// chatSocket.js의 connectStomp에서
if (stompClient) {
  console.log('🔥 [ChatSocket] 기존 연결 해제 중...');
  try {
    if (subscription) {
      subscription.unsubscribe();
    }
    stompClient.deactivate();
  } catch (e) {
    console.warn('기존 연결 해제 실패:', e);
  }
  // ⭐ 명시적으로 null 설정 후 새 클라이언트 생성
  stompClient = null;
  subscription = null;
  
  // ⭐ 짧은 대기 후 새 클라이언트 생성 (deactivate 완료 대기)
  await new Promise(resolve => setTimeout(resolve, 50));
}
```

---

## 종합 개선 사항 요약

### 우선순위 높음
1. ✅ **UNREAD_COUNT_UPDATE 대기 큐 구현**: 메시지가 아직 로드되지 않은 경우를 처리
2. ✅ **disconnectStomp Promise화**: 구독 해제 완료 후 새 구독 생성 보장
3. ✅ **구독 해제 로직 개선**: 안전한 구독 해제 및 null 설정

### 우선순위 중간
4. ⚠️ **Race condition 방지**: `messages` 직접 참조 제거, `prev` 사용 강화
5. ⚠️ **채팅방 변경 시 큐 초기화**: 대기 중인 업데이트 초기화

### 우선순위 낮음
6. 📝 **로깅 개선**: 디버깅을 위한 상세 로그 추가 (이미 충분히 있음)

---

## 테스트 시나리오

### 시나리오 1: UNREAD_COUNT_UPDATE 메시지 미로드 처리
1. 채팅방 A에 접속
2. 다른 사용자가 메시지 전송 (UNREAD_COUNT_UPDATE 브로드캐스트)
3. 해당 메시지가 아직 로드되지 않은 상태에서 UNREAD_COUNT_UPDATE 수신
4. 메시지 로드 후 unreadCount가 올바르게 업데이트되는지 확인

### 시나리오 2: 채팅방 변경 시 구독 중복 방지
1. 채팅방 A에 접속 (구독 생성)
2. 채팅방 B로 즉시 변경
3. 구독이 중복되지 않고 B방만 구독되는지 확인

### 시나리오 3: Race Condition 테스트
1. 빠르게 여러 메시지 전송
2. UNREAD_COUNT_UPDATE와 일반 메시지가 동시에 도착
3. 모든 메시지의 unreadCount가 올바르게 업데이트되는지 확인

