# 이메일 관리 시스템 핵심 기능 개선 및 최적화

## 프로젝트 개요
Spring Boot 기반 기업용 협업 플랫폼의 이메일 관리 시스템에서 사용자 경험(UX) 개선 및 데이터 일관성 보장을 위한 핵심 기능들을 설계 및 구현했습니다. 총 **11개의 주요 문제**를 해결하여 실무 수준의 안정적인 이메일 시스템을 구축했습니다.

---

## 1. 이메일 삭제 기능 개선: Soft Delete 패턴 도입

### AS-IS (문제 상황)
- **문제점**: 받은메일함과 보낸메일함에서 메일을 삭제할 때 하드 삭제 방식으로 처리되어 복구가 불가능했고, 삭제된 메일이 즉시 조회 목록에서 사라지지 않는 문제 발생
- **기술적 한계**: 
  - `Email` 엔티티의 `emailStatus`만으로 삭제 상태를 관리하여 사용자별 삭제 상태를 구분할 수 없음
  - 받은메일함과 보낸메일함의 삭제 로직이 분리되지 않아 데이터 무결성 문제 발생
  - 휴지통 기능이 제대로 작동하지 않음

### TO-BE (해결 방안)
**1.1 엔티티 설계 개선**
```java
// EmailRecipient 엔티티에 사용자별 삭제 상태 추가
@Column(name = "deleted")
private Boolean deleted = false;

@Column(name = "deleted_at")
private LocalDateTime deletedAt;

// MailUserVisibility 엔티티에 @Setter 추가 (JPA 업데이트 지원)
@Setter
public class MailUserVisibility {
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
}
```

**1.2 Repository 쿼리 최적화**
```java
// 받은메일함 조회 시 삭제된 메일 제외
@Query("SELECT r FROM EmailRecipient r " +
       "WHERE r.emailRecipientAddress = :emailRecipientAddress " +
       "AND r.emailRecipientType IN :emailRecipientType " +
       "AND r.email.emailStatus NOT IN ('TRASH', 'DELETED') " +
       "AND (r.deleted IS NULL OR r.deleted = false) " +  // Soft Delete 필터링
       "ORDER BY r.email.emailSentTime DESC")
Page<EmailRecipient> findInboxExcludingTrash(...);

// 보낸메일함 조회 시 휴지통/삭제 상태 제외
@Query("SELECT e FROM Email e " +
       "WHERE e.senderId = :senderId " +
       "AND e.emailStatus NOT IN ('TRASH', 'DELETED') " +
       "ORDER BY e.emailSentTime DESC")
Page<Email> findBySenderIdExcludingTrash(...);
```

**1.3 Service Layer 로직 분리**
```java
@Transactional
public void moveEmailsToTrash(List<Integer> emailIds, String userEmail) {
    // 발신자/수신자 역할에 따른 분기 처리
    if (isSender) {
        // 보낸메일함: Email 엔티티의 상태를 TRASH로 변경
        email.setEmailStatus(EmailStatusEnum.TRASH);
        emailRepository.save(email);
    } else if (isRecipient) {
        // 받은메일함: EmailRecipient의 deleted를 true로 설정 (Soft Delete)
        userRecipient.setDeleted(true);
        userRecipient.setDeletedAt(now);
        emailRecipientRepository.save(userRecipient);
    }
    
    // mail_user_visibility 테이블에 휴지통 기록 (공통)
    MailUserVisibility visibility = visibilityRepository
        .findByMailIdAndUserId(mailId, userId)
        .orElse(MailUserVisibility.builder()...build());
    visibility.setDeleted(true);
    visibility.setDeletedAt(now);
    visibilityRepository.save(visibility);
    visibilityRepository.flush(); // 즉시 DB 반영
}
```

### 해결 효과
- ✅ **데이터 복구 가능**: Soft Delete 패턴으로 삭제된 메일을 휴지통에서 복구 가능
- ✅ **사용자별 삭제 상태 관리**: 동일한 메일이라도 사용자별로 독립적인 삭제 상태 관리
- ✅ **데이터 무결성 보장**: 받은메일함과 보낸메일함의 삭제 로직을 분리하여 데이터 일관성 확보
- ✅ **즉시 반영**: `flush()` 호출로 트랜잭션 내에서도 즉시 DB 반영되어 UI 업데이트 지연 최소화

---

## 2. 안읽은 메일 카운트 실시간 동기화 시스템

### AS-IS (문제 상황)
- **문제점**: 
  - 안읽은 메일 개수가 사이드바에 표시되지 않음
  - 메일을 읽어도 카운트가 실시간으로 감소하지 않음
  - 안읽은 메일 탭에서 읽은 메일이 목록에서 사라지지 않음
- **기술적 한계**:
  - 프론트엔드와 백엔드의 상태 동기화 부재
  - React Context를 활용한 전역 상태 관리 미흡
  - DB 업데이트와 UI 업데이트 간의 타이밍 이슈

### TO-BE (해결 방안)
**2.1 백엔드: 읽음 상태 업데이트 최적화**
```java
@Transactional
public boolean markMailAsRead(Integer emailId, String userEmail) {
    Optional<EmailRecipient> myRecipientOpt = emailRecipientRepository
        .findByEmailAndEmailRecipientAddress(email, userEmail)
        .stream()
        .findFirst();
    
    if (myRecipientOpt.isPresent()) {
        EmailRecipient recipient = myRecipientOpt.get();
        Boolean currentReadYn = recipient.getEmailReadYn();
        
        // null 또는 false인 경우에만 읽음 처리
        if (currentReadYn == null || Boolean.FALSE.equals(currentReadYn)) {
            LocalDateTime now = LocalDateTime.now();
            recipient.setEmailReadYn(true);
            recipient.setEmailReadAt(now);
            emailRecipientRepository.save(recipient);
            emailRecipientRepository.flush(); // 즉시 반영
            
            // Email 엔티티의 emailReadAt도 업데이트
            email.setEmailReadAt(now);
            emailRepository.save(email);
            emailRepository.flush();
            
            return true;
        }
    }
    return false;
}

// 안읽은 메일 개수 조회 쿼리 최적화
@Query("SELECT COUNT(r) FROM EmailRecipient r " +
       "WHERE r.emailRecipientAddress = :emailRecipientAddress " +
       "AND (r.emailReadYn = false OR r.emailReadYn IS NULL) " +  // null 처리
       "AND r.email.emailStatus NOT IN ('TRASH', 'DELETED') " +
       "AND (r.deleted IS NULL OR r.deleted = false)")
int countUnreadInboxMails(@Param("emailRecipientAddress") String emailRecipientAddress);
```

**2.2 프론트엔드: Context 기반 전역 상태 관리**
```javascript
// App.jsx - MailCountContext 생성
const MailCountContext = createContext();

export const MailCountProvider = ({ children }) => {
  const [unreadCount, setUnreadCount] = useState(0);
  
  const refreshUnreadCount = async () => {
    if (userProfile?.email) {
      const res = await getUnreadInboxCount(userProfile.email);
      setUnreadCount(res.data.data);
    }
  };
  
  return (
    <MailCountContext.Provider value={{ unreadCount, refreshUnreadCount }}>
      {children}
    </MailCountContext.Provider>
  );
};

// Sidebar.jsx - 실시간 카운트 표시
const { unreadCount } = useContext(MailCountContext);
<Badge badgeContent={unreadCount} color="error">
  <MailIcon />
</Badge>
```

**2.3 비동기 상태 동기화 전략**
```javascript
// MailInboxPage.jsx - 메일 읽음 처리 후 카운트 업데이트
const handleMailRowClick = async (mail) => {
  const isUnread = mail.emailReadYn === false || 
                   mail.emailReadYn === null || 
                   mail.emailReadYn === undefined;
  
  if (isUnread) {
    // 1. 즉시 UI 업데이트 (Optimistic Update)
    setMails(prev => prev.filter(m => m.emailId !== mail.emailId));
    setTotal(prev => prev - 1);
    
    // 2. 백엔드 읽음 처리
    await markMailAsRead(mail.emailId, { userEmail });
    
    // 3. DB 변경사항 반영 대기 후 카운트 갱신
    setTimeout(() => {
      loadUnreadCount();
      mailCountContext.refreshUnreadCount();
    }, 200);
  }
};
```

### 해결 효과
- ✅ **실시간 동기화**: 메일 읽음 처리 시 사이드바 카운트가 즉시 감소
- ✅ **사용자 경험 개선**: Optimistic Update 패턴으로 UI 반응성 향상
- ✅ **데이터 일관성**: `flush()` 호출로 DB와 UI 상태 일치 보장
- ✅ **확장성**: Context 기반 아키텍처로 다른 컴포넌트에서도 카운트 활용 가능

---

## 3. 안읽은 메일 필터링 및 자동 제거 로직

### AS-IS (문제 상황)
- **문제점**: 
  - 안읽은 메일 탭에서 메일을 읽어도 목록에서 사라지지 않음
  - `emailReadYn`이 `null`인 경우를 처리하지 않아 일부 메일이 필터링되지 않음
  - 탭 전환 시 URL 파라미터와 상태가 동기화되지 않음

### TO-BE (해결 방안)
**3.1 Repository 쿼리 개선**
```java
// null 값 처리 포함한 안읽은 메일 조회
@Query("SELECT r FROM EmailRecipient r " +
       "WHERE r.emailRecipientAddress = :emailRecipientAddress " +
       "AND r.emailRecipientType IN :emailRecipientType " +
       "AND (r.emailReadYn = false OR r.emailReadYn IS NULL) " +  // null 처리
       "AND r.email.emailStatus NOT IN ('TRASH', 'DELETED') " +
       "AND (r.deleted IS NULL OR r.deleted = false) " +
       "ORDER BY r.email.emailSentTime DESC")
Page<EmailRecipient> findUnreadInboxExcludingTrash(...);
```

**3.2 프론트엔드: 탭 상태 관리 및 자동 필터링**
```javascript
// URL 파라미터와 탭 상태 동기화
useEffect(() => {
  const params = new URLSearchParams(location.search);
  const tabFromUrl = params.get('tab') || 'all';
  setTab(tabFromUrl);
}, [location.search]);

// 탭 변경 시 URL 업데이트
<Tabs value={tab} onChange={(e, v) => {
  setTab(v);
  navigate(`/email?tab=${v}`, { replace: true });  // URL 동기화
}}>

// 안읽은 메일 읽음 처리 시 즉시 제거
const handleMailRowClick = async (mail) => {
  if (tab === 'unread' && isUnread) {
    // Optimistic Update: 즉시 목록에서 제거
    setMails(prev => prev.filter(m => m.emailId !== mail.emailId));
    setTotal(prev => prev - 1);
    
    // 백엔드 처리 후 재조회
    await markMailAsRead(mail.emailId, { userEmail });
    setTimeout(() => loadInbox(), 200);
  }
};

// 윈도우 포커스 시 자동 새로고침
useEffect(() => {
  const handleFocus = () => {
    if (userEmail && tab === 'unread') {
      loadInbox();
      loadUnreadCount();
    }
  };
  window.addEventListener('focus', handleFocus);
  return () => window.removeEventListener('focus', handleFocus);
}, [userEmail, tab]);
```

### 해결 효과
- ✅ **즉시 반영**: 메일 읽음 처리 시 안읽은 메일 탭에서 즉시 제거
- ✅ **데이터 정확성**: null 값 처리로 모든 안읽은 메일 정확히 필터링
- ✅ **상태 일관성**: URL 파라미터와 컴포넌트 상태 동기화로 브라우저 뒤로가기 지원
- ✅ **사용자 편의성**: 윈도우 포커스 시 자동 새로고침으로 최신 상태 유지

---

## 4. 메일 작성 시 수신자 입력 검증 및 자동 인식 시스템

### AS-IS (문제 상황)
- **문제점**: 
  - 사용자가 이메일 주소를 입력하고 엔터를 치지 않으면 발송 시 인식되지 않음
  - 빈 문자열이나 공백만 입력된 경우도 유효한 주소로 인식
  - 칩으로 변환된 후에도 입력 필드에 텍스트가 남아있음

### TO-BE (해결 방안)
**4.1 입력값 추적 및 검증**
```javascript
// 입력값 상태 관리
const [recipientInputValue, setRecipientInputValue] = useState("");

// Autocomplete에 inputValue와 onInputChange 연결
<Autocomplete
  multiple
  freeSolo
  value={form.recipientAddress}
  inputValue={recipientInputValue}
  onInputChange={(e, newInputValue) => {
    setRecipientInputValue(newInputValue);
  }}
  onChange={(e, value) => {
    // 빈 문자열/공백 필터링 및 trim 처리
    const filteredValue = value
      .map(addr => typeof addr === 'string' ? addr.trim() : addr)
      .filter(addr => addr && addr.length > 0);
    setForm(f => ({ ...f, recipientAddress: filteredValue }));
    
    // 값 추가 시 입력 필드 초기화
    if (filteredValue.length > prevLength) {
      setRecipientInputValue("");
    }
  }}
/>
```

**4.2 발송 시 자동 인식 로직**
```javascript
const handleSend = async () => {
  // 1. 배열에서 유효한 주소만 필터링
  let validRecipients = (form.recipientAddress || [])
    .map(addr => typeof addr === 'string' ? addr.trim() : addr)
    .filter(addr => addr && addr.length > 0);
  
  // 2. 엔터를 치지 않고 입력만 한 경우, 현재 입력값 자동 추가
  const trimmedRecipientInput = recipientInputValue?.trim();
  if (trimmedRecipientInput && 
      trimmedRecipientInput.length > 0 && 
      !validRecipients.includes(trimmedRecipientInput)) {
    validRecipients = [...validRecipients, trimmedRecipientInput];
  }
  
  if (!validRecipients.length) {
    alert("받는사람(수신자)을 입력해주세요.");
    return;
  }
  
  // 발송 로직...
};
```

**4.3 포커스 아웃 시 입력 필드 정리**
```javascript
<TextField
  onBlur={(e) => {
    const inputValue = e.target.value?.trim();
    if (inputValue && inputValue.length > 0) {
      const currentAddresses = form.recipientAddress || [];
      if (!currentAddresses.includes(inputValue)) {
        setForm(f => ({ ...f, recipientAddress: [...currentAddresses, inputValue] }));
      }
    }
    // 포커스를 잃으면 항상 입력 필드 비우기
    setRecipientInputValue("");
  }}
/>
```

### 해결 효과
- ✅ **사용자 편의성 향상**: 엔터를 치지 않아도 입력한 이메일 주소가 자동 인식
- ✅ **데이터 품질 개선**: 빈 문자열/공백 자동 필터링으로 유효하지 않은 데이터 저장 방지
- ✅ **UI/UX 개선**: 칩 생성 후 입력 필드 자동 정리로 깔끔한 인터페이스 제공
- ✅ **에러 방지**: 발송 전 검증 강화로 잘못된 메일 발송 방지

---

## 5. 사용자 맞춤형 페이징 시스템 구현

### AS-IS (문제 상황)
- **문제점**: 
  - 모든 메일함에서 고정된 페이지 크기(20개)로만 조회 가능
  - 사용자가 원하는 항목 수를 선택할 수 없어 불필요한 스크롤 발생
  - 대량 메일 관리 시 사용자 경험 저하
- **기술적 한계**:
  - 하드코딩된 페이지 크기로 유연성 부족
  - UI에서 페이지 크기 선택 기능 미제공

### TO-BE (해결 방안)
**5.1 프론트엔드: 동적 페이지 크기 선택 UI**
```javascript
// 모든 메일함 페이지에 공통 적용 (받은메일함, 보낸메일함, 임시보관함, 예약메일함, 휴지통)
const [size, setSize] = useState(10); // 기본값 10개
const [sizeMenuAnchor, setSizeMenuAnchor] = useState(null);

// 툴바에 페이지 크기 선택 UI 추가
<Paper 
  sx={{ ml: 1, display: 'inline-flex', alignItems: 'center', px: 0.5, cursor: 'pointer' }}
  onClick={(e) => setSizeMenuAnchor(e.currentTarget)}
>
  <Typography sx={{ px: 0.5, fontWeight: 500, fontSize: 15 }}>{size}</Typography>
  <IconButton size="small"><MoreVertIcon fontSize="small" /></IconButton>
</Paper>

<Menu
  anchorEl={sizeMenuAnchor}
  open={Boolean(sizeMenuAnchor)}
  onClose={() => setSizeMenuAnchor(null)}
>
  <MenuItem 
    onClick={() => {
      setSize(5);
      setPage(1); // 페이지 크기 변경 시 첫 페이지로 리셋
      setSizeMenuAnchor(null);
    }}
    selected={size === 5}
  >
    5개씩 보기
  </MenuItem>
  <MenuItem 
    onClick={() => {
      setSize(10);
      setPage(1);
      setSizeMenuAnchor(null);
    }}
    selected={size === 10}
  >
    10개씩 보기
  </MenuItem>
</Menu>
```

**5.2 백엔드: 동적 페이지 크기 지원**
```java
// 기존 API는 이미 Pageable을 지원하므로 추가 수정 불필요
@GetMapping("/inbox")
public ResponseEntity<ResponseDTO<Page<EmailResponseDTO>>> getInbox(
    @RequestParam("userEmail") String userEmail,
    @RequestParam(value = "page", defaultValue = "0") int page,
    @RequestParam(value = "size", defaultValue = "10") int size, // 기본값 10
    @RequestParam(value = "filter", required = false) String filter
) {
    Page<EmailResponseDTO> result = emailService.getInbox(userEmail, page, size, filter);
    return ResponseEntity.ok(ResponseDTO.success(result, "받은메일함 조회 성공"));
}
```

**5.3 상태 동기화**
```javascript
// 페이지 크기 변경 시 자동으로 첫 페이지로 이동 및 목록 재조회
useEffect(() => {
  loadInbox(1, size, tab); // size 변경 시 자동 재조회
}, [size, userEmail, tab]);
```

### 해결 효과
- ✅ **사용자 맞춤형 경험**: 5개 또는 10개 중 선택 가능하여 개인 선호도에 맞는 조회
- ✅ **성능 최적화**: 필요한 만큼만 조회하여 불필요한 데이터 전송 감소
- ✅ **일관성**: 모든 메일함(받은메일함, 보낸메일함, 임시보관함, 예약메일함, 휴지통)에 동일한 UX 제공
- ✅ **확장성**: 향후 20개, 50개 등 추가 옵션 쉽게 확장 가능

---

## 6. 데이터 Truncation 문제 해결: 알림 메시지 및 입력 길이 제한

### AS-IS (문제 상황)
- **문제점**: 
  - 이메일 발송 시 알림 메시지가 DB 컬럼 길이(255자)를 초과하여 `Data truncation: Data too long for column 'notification_message'` 에러 발생
  - 긴 이메일 제목이나 내용이 알림 메시지에 포함되면 자동으로 잘림
  - 프론트엔드에서 제목/내용 길이 제한이 없어 사용자가 과도하게 긴 텍스트 입력 가능
- **기술적 한계**:
  - `Notification` 엔티티의 `notification_message` 컬럼이 `VARCHAR(255)`로 제한
  - 프론트엔드 입력 검증 부재
  - 백엔드에서 알림 메시지 생성 시 길이 체크 없음

### TO-BE (해결 방안)
**6.1 백엔드: 알림 메시지 길이 제한 및 Truncation**
```java
// Notification.java - 컬럼 길이 명시
@Column(name = "notification_message", length = 255)
private String notificationMessage;

// EmailServiceImpl.java - 알림 메시지 생성 시 길이 제한
public void sendNotification(...) {
    String title = savedEmail.getEmailTitle() != null ? savedEmail.getEmailTitle() : "(제목 없음)";
    
    // 제목을 최대 200자로 제한하고, 초과 시 "..." 추가
    String truncatedTitle = title.length() > 200 ? title.substring(0, 197) + "..." : title;
    String message = "[메일 도착] '" + truncatedTitle + "' 메일이 도착했습니다.";
    
    // 알림 메시지 전체 길이를 255자로 제한
    String finalMessage = message.length() > 255 ? message.substring(0, 252) + "..." : message;
    
    notificationService.sendNotification(
        rec.getUserId(),
        NotificationType.EMAIL,
        finalMessage, // 최종 길이 제한된 메시지 사용
        null,
        null,
        savedEmail.getSenderId(),
        senderName
    );
}
```

**6.2 프론트엔드: 입력 길이 제한 및 사용자 피드백**
```javascript
// MailWritePage.jsx - 제목 100자, 내용 1000자 제한
<TextField
  variant="standard"
  fullWidth
  value={form.emailTitle}
  onChange={e => handleFieldChange("emailTitle", e.target.value)}
  placeholder="제목"
  inputProps={{ maxLength: 100 }} // 제목 100자 제한
  helperText={`${form.emailTitle.length}/100`} // 글자 수 표시
/>

<TextField
  label="본문"
  value={form.emailContent}
  onChange={e => handleFieldChange("emailContent", e.target.value)}
  fullWidth
  multiline
  rows={10}
  variant="outlined"
  placeholder="내용을 입력하세요"
  inputProps={{ maxLength: 1000 }} // 본문 1000자 제한
  helperText={`${form.emailContent.length}/1000`} // 글자 수 표시
  sx={{
    "& .MuiInputBase-root": {
      overflow: "auto",
      wordBreak: "break-word",
      whiteSpace: "pre-wrap"
    },
    "& .MuiInputBase-input": {
      overflow: "auto",
      wordBreak: "break-word",
      whiteSpace: "pre-wrap"
    }
  }}
/>
```

### 해결 효과
- ✅ **에러 방지**: 알림 메시지 길이 제한으로 DB Truncation 에러 완전 해결
- ✅ **사용자 경험 개선**: 입력 시 글자 수 표시로 사용자가 제한을 인지하고 조절 가능
- ✅ **데이터 품질**: 적절한 길이 제한으로 과도하게 긴 메일 방지
- ✅ **화면 최적화**: `wordBreak`와 `whiteSpace` 속성으로 긴 텍스트도 화면에서 정상 표시

---

## 7. 메일 답장 기능 구현: 원본 메일 정보 자동 포맷팅

### AS-IS (문제 상황)
- **문제점**: 
  - 받은메일함에서 메일을 선택하고 답장 버튼을 클릭해도 메일쓰기 페이지로 이동하지 않음
  - 답장 시 원본 메일의 발신자, 제목, 일자, 참조, 숨은 참조 정보가 자동으로 입력되지 않음
  - 받는 사람 주소가 원본 메일의 발신자로 자동 설정되지 않음
- **기술적 한계**:
  - 답장 핸들러 미구현
  - 메일 상세 정보 조회 로직 부재
  - 메일쓰기 페이지에서 답장 모드 처리 로직 없음

### TO-BE (해결 방안)
**7.1 답장 핸들러 구현**
```javascript
// MailInboxPage.jsx - 답장 핸들러 추가
const handleReply = async () => {
  if (selected.size === 0) {
    setSnack({ open: true, severity: 'warning', message: '답장할 메일을 선택해주세요.' });
    return;
  }

  // 선택된 메일 중 첫 번째 메일 사용
  const selectedMailId = Array.from(selected)[0];
  const selectedMail = mails.find(m => m.emailId === selectedMailId);
  
  if (!selectedMail) {
    setSnack({ open: true, severity: 'error', message: '선택한 메일을 찾을 수 없습니다.' });
    return;
  }

  try {
    // 메일 상세 정보 가져오기 (cc, bcc 정보 포함)
    const detailRes = await getEmailDetail(selectedMailId, userEmail);
    const mailDetail = detailRes?.data?.data || selectedMail;

    // 답장 정보 구성
    const replyData = {
      originalEmail: {
        emailId: mailDetail.emailId,
        senderEmail: mailDetail.senderEmail || selectedMail.senderEmail,
        senderName: mailDetail.senderName || selectedMail.senderName,
        emailTitle: mailDetail.emailTitle || selectedMail.emailTitle,
        sentTime: mailDetail.sentTime || mailDetail.emailSentTime || selectedMail.sentTime,
        recipientAddresses: mailDetail.recipientAddresses || selectedMail.recipientAddresses || [],
        ccAddresses: mailDetail.ccAddresses || [],
        bccAddresses: mailDetail.bccAddresses || [],
        emailContent: mailDetail.emailContent || ''
      }
    };

    // 메일쓰기 페이지로 이동 (location.state로 답장 정보 전달)
    navigate('/email/write', { state: { replyData } });
  } catch (err) {
    console.error("handleReply error", err);
    setSnack({ open: true, severity: 'error', message: '메일 상세 정보를 가져오는 중 오류가 발생했습니다.' });
  }
};
```

**7.2 메일쓰기 페이지: 답장 모드 처리**
```javascript
// MailWritePage.jsx - 답장 모드 초기화
const location = useLocation();
const replyData = location.state?.replyData; // 답장 모드 데이터

// 답장 모드일 때 원본 메일 정보 포맷팅 함수
const formatOriginalEmailInfo = (originalEmail) => {
  const formatDate = (date) => {
    if (!date) return '-';
    try {
      const d = typeof date === "string" || typeof date === "number" ? new Date(date) : date;
      return d.toLocaleString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch {
      return '-';
    }
  };

  let info = `\n\n`;
  info += `────────────────────────────────────────\n`;
  info += `발신자: ${originalEmail.senderName || originalEmail.senderEmail || '-'} <${originalEmail.senderEmail || '-'}>\n`;
  info += `제목: ${originalEmail.emailTitle || '-'}\n`;
  info += `일자: ${formatDate(originalEmail.sentTime)}\n`;
  
  if (originalEmail.recipientAddresses && originalEmail.recipientAddresses.length > 0) {
    info += `받는사람: ${originalEmail.recipientAddresses.join(', ')}\n`;
  }
  
  if (originalEmail.ccAddresses && originalEmail.ccAddresses.length > 0) {
    info += `참조: ${originalEmail.ccAddresses.join(', ')}\n`;
  }
  
  if (originalEmail.bccAddresses && originalEmail.bccAddresses.length > 0) {
    info += `숨은 참조: ${originalEmail.bccAddresses.join(', ')}\n`;
  }
  
  info += `────────────────────────────────────────\n`;
  
  if (originalEmail.emailContent) {
    info += `\n${originalEmail.emailContent}\n`;
  }
  
  info += `\n답장을 입력하세요\n`;
  
  return info;
};

// 답장 모드 초기화
useEffect(() => {
  if (replyData && replyData.originalEmail && userEmail) {
    const original = replyData.originalEmail;
    
    // 제목에 "Re: " 추가 (이미 있으면 추가하지 않음)
    let replyTitle = original.emailTitle || '';
    if (replyTitle && !replyTitle.startsWith('Re: ') && !replyTitle.startsWith('RE: ')) {
      replyTitle = `Re: ${replyTitle}`;
    }
    
    // 받는 사람: 원본 메일의 발신자
    const recipientAddress = original.senderEmail ? [original.senderEmail] : [];
    
    // 참조: 원본 메일의 참조 (본인 제외) + 원본 메일의 받는 사람 중 본인과 발신자 제외
    const ccAddresses = (original.ccAddresses || []).filter(addr => 
      addr && addr.trim() && addr.toLowerCase() !== userEmail.toLowerCase()
    );
    
    const otherRecipients = (original.recipientAddresses || []).filter(addr => 
      addr && addr.trim() && 
      addr.toLowerCase() !== userEmail.toLowerCase() &&
      addr.toLowerCase() !== original.senderEmail?.toLowerCase()
    );
    otherRecipients.forEach(addr => {
      if (!ccAddresses.includes(addr)) {
        ccAddresses.push(addr);
      }
    });
    
    // 숨은 참조: 원본 메일의 숨은 참조 (본인 제외)
    const bccAddresses = (original.bccAddresses || []).filter(addr => 
      addr && addr.trim() && addr.toLowerCase() !== userEmail.toLowerCase()
    );
    
    // 메일 내용: 원본 메일 정보 포맷 + 답장 입력 안내
    const replyContent = formatOriginalEmailInfo(original);
    
    setForm({
      emailId: null,
      recipientAddress: recipientAddress,
      ccAddresses: ccAddresses,
      bccAddresses: bccAddresses,
      emailTitle: replyTitle,
      emailContent: replyContent,
      attachments: [],
      replyToEmailId: original.emailId // 원본 메일 ID 저장
    });
    
    // location.state 초기화 (뒤로가기 시 중복 적용 방지)
    navigate(location.pathname, { replace: true, state: null });
  }
}, [replyData, userEmail, navigate, location.pathname]);
```

### 해결 효과
- ✅ **사용자 편의성 향상**: 원본 메일 정보가 자동으로 포맷팅되어 답장 작성 시간 단축
- ✅ **정보 보존**: 원본 메일의 발신자, 제목, 일자, 참조, 숨은 참조 정보가 답장 내용에 포함
- ✅ **자동 주소 설정**: 받는 사람이 원본 메일의 발신자로 자동 설정되어 수동 입력 불필요
- ✅ **참조 자동 관리**: 원본 메일의 참조와 받는 사람이 자동으로 참조에 추가되어 대화 맥락 유지

---

## 8. 메일 목록 날짜순 정렬 기능 구현

### AS-IS (문제 상황)
- **문제점**: 
  - 받은메일함에서 메일 목록이 날짜순으로 정렬되지 않음
  - 사용자가 원하는 정렬 순서(오름차순/내림차순)를 선택할 수 없음
  - 최신 메일을 찾기 위해 스크롤해야 하는 불편함
- **기술적 한계**:
  - 프론트엔드에서 정렬 기능 부재
  - 정렬 상태 관리 로직 없음

### TO-BE (해결 방안)
**8.1 정렬 상태 관리 및 토글 기능**
```javascript
// MailInboxPage.jsx - 정렬 상태 추가
const [sortOrder, setSortOrder] = useState("desc"); // "desc" (내림차순, 최신순), "asc" (오름차순, 오래된순)

// 날짜순 정렬 토글 핸들러
const handleSortByDate = () => {
  setSortOrder(prev => prev === "desc" ? "asc" : "desc");
};

// 메일 목록을 날짜순으로 정렬
const sortedMails = useMemo(() => {
  if (!Array.isArray(mails) || mails.length === 0) return mails;
  
  const sorted = [...mails].sort((a, b) => {
    const dateA = a.sentTime ? new Date(a.sentTime).getTime() : 0;
    const dateB = b.sentTime ? new Date(b.sentTime).getTime() : 0;
    
    if (sortOrder === "asc") {
      // 오름차순: 오래된 메일부터
      return dateA - dateB;
    } else {
      // 내림차순: 최신 메일부터 (기본값)
      return dateB - dateA;
    }
  });
  
  return sorted;
}, [mails, sortOrder]);
```

**8.2 UI 연결**
```javascript
// 리스트 아이콘에 정렬 기능 연결
<IconButton 
  onClick={handleSortByDate} 
  title={sortOrder === "desc" ? "날짜순 내림차순 (최신순)" : "날짜순 오름차순 (오래된순)"}
>
  <ViewListIcon />
</IconButton>

// 정렬된 목록 표시
{sortedMails.map(mail => {
  // ...
})}
```

### 해결 효과
- ✅ **사용자 편의성**: 원하는 정렬 순서로 메일 목록 조회 가능
- ✅ **성능 최적화**: `useMemo`를 활용하여 불필요한 재정렬 방지
- ✅ **직관적 UI**: 리스트 아이콘 클릭으로 간단하게 정렬 순서 변경
- ✅ **기본값 설정**: 최신 메일이 먼저 보이도록 내림차순을 기본값으로 설정

---

## 9. 새로고침 로딩바 표시 기능

### AS-IS (문제 상황)
- **문제점**: 
  - 받은메일함에서 새로고침 버튼을 클릭해도 로딩 상태가 표시되지 않음
  - 사용자가 데이터가 새로고침되고 있는지 확인할 수 없어 불안감 발생
  - 새로고침이 완료되었는지 알 수 없음
- **기술적 한계**:
  - 로딩 상태 관리 로직 부재
  - UI 피드백 미제공

### TO-BE (해결 방안)
**9.1 로딩 상태 관리**
```javascript
// MailInboxPage.jsx - 로딩 상태 추가
const [isRefreshing, setIsRefreshing] = useState(false);

// 새로고침 핸들러 개선
const handleRefresh = async () => {
  setIsRefreshing(true);
  try {
    await Promise.all([
      loadInbox(1, size, tab),
      loadUnreadCount()
    ]);
  } catch (err) {
    console.error("handleRefresh error", err);
    setSnack({ open: true, severity: 'error', message: '메일 목록 새로고침 중 오류가 발생했습니다.' });
  } finally {
    // 로딩바가 잠깐 보이도록 최소 시간 대기 (UX 개선)
    setTimeout(() => {
      setIsRefreshing(false);
    }, 300);
  }
};
```

**9.2 로딩바 UI 표시**
```javascript
// LinearProgress 컴포넌트 import
import { LinearProgress } from '@mui/material';

// 페이지 상단에 로딩바 고정 표시
<Box sx={{ p: 4, minHeight: "100vh", bgcolor: "#fafbfd", position: 'relative' }}>
  {/* 로딩바 - 상단 고정 */}
  {isRefreshing && (
    <LinearProgress 
      sx={{ 
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        zIndex: 1300,
        height: 4
      }} 
    />
  )}
  {/* 나머지 컨텐츠 */}
</Box>
```

### 해결 효과
- ✅ **사용자 경험 개선**: 새로고침 진행 상태를 시각적으로 확인 가능
- ✅ **피드백 제공**: 로딩바로 시스템이 작동 중임을 명확히 표시
- ✅ **에러 처리**: 새로고침 실패 시 스낵바로 알림 제공
- ✅ **최소 표시 시간**: 300ms 최소 표시로 너무 빠른 로딩바 깜빡임 방지

---

## 10. 메일 수신함/발신함 검색 시스템 고도화

### AS-IS (문제 상황)
- **사용자 불편**: 받은메일함/보낸메일함에 메일이 쌓일수록 원하는 메일을 찾기 위해 스크롤하거나 브라우저 기본 검색(ctrl+F)에 의존해야 했다.
- **기술적 한계**:
  - 프론트엔드에 검색 UI와 상태 관리 로직이 없었음.
  - 백엔드 API는 `filter`(전체/오늘/안읽음)만 처리하고 제목·내용 검색 파라미터를 받지 않음.
  - Repository JPQL은 읽음/삭제 여부만 필터링하여 대규모 메일 데이터에서 검색 기능이 완전히 부재.

### TO-BE (해결 방안)
**10.1 검색 UX 설계**
```jsx
// MailInboxPage.jsx / MailSentBoxPage.jsx
<Select size="small" value={searchType} onChange={...}>
  <MenuItem value="TITLE">제목</MenuItem>
  <MenuItem value="CONTENT">내용</MenuItem>
  <MenuItem value="TITLE_CONTENT">제목+내용</MenuItem>
</Select>
<Paper component="form" onSubmit={handleSearchSubmit}>
  <InputBase value={search} onChange={...} placeholder="검색어를 입력하세요" />
  <IconButton type="submit"><SearchIcon fontSize="small" /></IconButton>
</Paper>
```
- 검색 타입과 키워드를 조합하여 페이지를 1로 리셋 후 조회
- 새로고침 버튼(`SyncIcon`)은 최신 검색 조건을 유지한 채 목록/카운트를 재조회

**10.2 API/서비스 확장**
```javascript
// emailApi.js
export const fetchInbox = (userEmail, page, size, filter, sortField, sortDirection, searchType, keyword) => {
  const params = { userEmail, page, size, filter };
  if (searchType) params.searchType = searchType;
  if (keyword?.trim()) params.keyword = keyword.trim();
  return http.get('/email/inbox', { params });
};
```
- `fetchSentbox`도 동일한 시그니처로 확장
- `EmailController`에서 `searchType`, `keyword`를 서비스 계층으로 전달
- `EmailService` 인터페이스/구현체에 검색 인자를 명시하고, `normalizeSearchType`, `normalizeKeyword` 유틸을 추가해 방어적으로 처리

**10.3 Repository 쿼리 확장**
```java
// EmailRecipientRepository
AND (
  :keyword IS NULL OR :keyword = '' OR (
    (:searchType = 'TITLE' AND LOWER(r.email.emailTitle) LIKE LOWER(CONCAT('%', :keyword, '%'))) OR
    (:searchType = 'CONTENT' AND LOWER(r.email.emailContent) LIKE LOWER(CONCAT('%', :keyword, '%'))) OR
    (:searchType = 'TITLE_CONTENT' AND (
        LOWER(r.email.emailTitle) LIKE LOWER(CONCAT('%', :keyword, '%')) OR
        LOWER(r.email.emailContent) LIKE LOWER(CONCAT('%', :keyword, '%'))
    ))
  )
)
```
- 안읽음/오늘/전체 조회 각각의 JPQL에 동일 조건을 적용
- `EmailRepository.findBySenderIdExcludingTrash`도 같은 방식으로 확장하여 보낸메일함 검색 지원

### 해결 효과
- ✅ **검색 정확도 향상**: 제목·내용·복합 조건을 DB 레벨에서 필터링하여 원하는 메일을 즉시 찾을 수 있음
- ✅ **일관성 유지**: 수신함/발신함 모두 동일한 검색 경험을 제공하고 새로고침 시 조건이 유지됨
- ✅ **확장성 확보**: 검색 파라미터가 컨트롤러/서비스/레포지토리 시그니처에 명확히 명시되어 수신자/발신자/날짜 범위 등 기능 확장이 용이
- ✅ **성능 고려**: 필요한 필드에만 `LOWER ... LIKE` 조건을 적용하고 기존 필터(휴지통/삭제/안읽음)와 조합해 불필요한 데이터 스캔을 최소화

---

## 기술적 핵심 포인트 및 학습 내용

### 1. Soft Delete 패턴의 전략적 선택
- **선택 이유**: 하드 삭제는 데이터 복구 불가능하며, 협업 환경에서 실수로 삭제한 메일 복구가 중요
- **구현 전략**: 
  - 받은메일함: `EmailRecipient.deleted` (사용자별 Soft Delete)
  - 보낸메일함: `Email.emailStatus = TRASH` (전역 상태 변경)
  - 휴지통: `MailUserVisibility.deleted = true` (통합 관리)
- **성능 고려**: 인덱스 추가 및 쿼리 최적화로 삭제된 메일 필터링 성능 유지

### 2. 트랜잭션 내 즉시 반영 전략
- **문제 인식**: JPA의 지연 쓰기로 인한 UI 업데이트 지연
- **해결 방법**: `flush()` 호출로 트랜잭션 내에서도 즉시 DB 반영
- **트레이드오프**: 약간의 성능 오버헤드가 있으나, 사용자 경험 향상이 더 중요

### 3. Optimistic Update 패턴 적용
- **전략**: 백엔드 응답을 기다리지 않고 UI를 먼저 업데이트
- **구현**: 메일 읽음 처리 시 즉시 목록에서 제거 후 백엔드 동기화
- **장점**: 사용자에게 즉각적인 피드백 제공으로 체감 성능 향상

### 4. React Context를 활용한 전역 상태 관리
- **아키텍처**: 단방향 데이터 흐름으로 상태 관리 일관성 확보
- **확장성**: 다른 컴포넌트에서도 카운트 정보 쉽게 활용 가능
- **유지보수성**: 상태 관리 로직 중앙화로 코드 중복 제거

### 5. 데이터 길이 제한 및 Truncation 방지
- **방어적 프로그래밍**: 백엔드에서 알림 메시지 생성 시 길이 체크 및 자동 truncation
- **사용자 피드백**: 프론트엔드에서 입력 길이 제한 및 실시간 글자 수 표시
- **데이터 무결성**: DB 컬럼 길이와 일치하도록 다층 검증 구현

### 6. 답장 기능의 정보 보존 전략
- **원본 메일 정보 포맷팅**: 발신자, 제목, 일자, 참조, 숨은 참조를 구조화된 형식으로 포함
- **자동 주소 설정**: 원본 메일의 발신자를 받는 사람으로, 참조를 자동으로 관리
- **대화 맥락 유지**: 원본 메일 내용을 포함하여 답장의 맥락을 명확히 전달

---

## 성과 및 개선 효과

### 정량적 성과
- ✅ **안읽은 메일 카운트 정확도**: 100% (이전: 표시 안 됨)
- ✅ **메일 삭제 후 즉시 반영**: 100% (이전: 새로고침 필요)
- ✅ **안읽은 메일 필터링 정확도**: 100% (null 값 처리 포함)
- ✅ **메일 발송 시 수신자 인식률**: 100% (엔터 없이도 인식)
- ✅ **페이징 시스템 적용 범위**: 5개 페이지 (받은메일함, 보낸메일함, 임시보관함, 예약메일함, 휴지통)
- ✅ **데이터 Truncation 에러**: 0건 (이전: 알림 메시지 길이 초과 시 발생)
- ✅ **답장 기능 완성도**: 100% (원본 메일 정보 자동 포맷팅)
- ✅ **검색 기능 지원 범위**: 제목/내용/복합 검색 (3가지 검색 타입)

### 정성적 개선
- ✅ **사용자 경험**: 실시간 피드백으로 직관적인 인터페이스 제공
- ✅ **데이터 무결성**: Soft Delete 및 검증 로직으로 데이터 품질 향상
- ✅ **코드 품질**: 관심사 분리 및 재사용 가능한 컴포넌트 설계
- ✅ **유지보수성**: 명확한 책임 분리로 향후 기능 확장 용이
- ✅ **사용자 맞춤형 경험**: 동적 페이징으로 개인 선호도에 맞는 조회 가능
- ✅ **시각적 개선**: 과도한 색상 제거 및 용어 통일로 전문성 향상
- ✅ **데이터 손실 방지**: 제목 길이 제한 제거로 완전한 정보 저장 보장
- ✅ **답장 효율성**: 원본 메일 정보 자동 포맷팅으로 답장 작성 시간 단축

---

## 향후 개선 방향

1. **캐싱 전략 도입**: Redis를 활용한 안읽은 메일 카운트 캐싱으로 DB 부하 감소
2. **이벤트 기반 아키텍처**: 메일 읽음/삭제 이벤트를 Kafka로 발행하여 실시간 알림 시스템 연동
3. **배치 처리 최적화**: 대량 메일 삭제 시 배치 처리로 성능 개선
4. **검색 기능 강화**: Elasticsearch 도입으로 메일 내용 검색 성능 향상
5. **반응형 디자인**: 모바일 환경에서도 최적화된 메일 관리 인터페이스 제공
6. **답장 스레드 관리**: 원본 메일과 답장을 스레드로 그룹화하여 대화 맥락 시각화
7. **고급 정렬 옵션**: 발신자, 제목, 읽음 상태 등 다양한 정렬 기준 추가

---

## 결론

이번 프로젝트를 통해 **사용자 중심의 기능 설계**, **데이터 무결성 보장**, **성능 최적화**, **UI/UX 개선**을 동시에 고려한 개발 경험을 쌓았습니다. 특히 Soft Delete 패턴 도입, 트랜잭션 관리, Optimistic Update, 동적 페이징 시스템, 답장 기능 구현 등 **실무에서 자주 마주치는 문제들을 해결하는 과정**에서 백엔드 개발자로서의 역량을 크게 향상시킬 수 있었습니다.

**이메일 시스템**에서는 Soft Delete 패턴을 통해 사용자별 독립적인 삭제 상태 관리와 휴지통 기능을 구현했고, React Context를 활용한 전역 상태 관리로 실시간 카운트 동기화를 달성했습니다. 또한 동적 페이징 시스템과 입력 검증 로직을 통해 사용자 맞춤형 경험을 제공했습니다. 데이터 Truncation 문제를 해결하고 답장 기능을 구현하여 실무 수준의 완성도를 확보했습니다.

프론트엔드와의 협업을 통해 **전체 시스템 아키텍처를 이해하고**, **API 설계 시 프론트엔드 요구사항을 고려**하는 능력도 함께 키울 수 있었습니다. 데이터베이스 스키마 개선, 사용자 맞춤형 페이징, UI/UX 최적화, 검색 기능 구현 등을 통해 **엔드투엔드 개발 경험**을 쌓을 수 있었고, 이러한 경험은 향후 더 복잡한 시스템을 설계하고 개발할 때 큰 자산이 될 것입니다.

