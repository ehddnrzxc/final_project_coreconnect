# 이메일 관리 시스템 핵심 기능 개선 및 최적화

## 프로젝트 개요
Spring Boot 기반 기업용 협업 플랫폼의 이메일 관리 시스템에서 사용자 경험(UX) 개선 및 데이터 일관성 보장을 위한 핵심 기능들을 설계 및 구현했습니다.

---

## 1. 이메일 삭제 기능 개선: Soft Delete 패턴 도입

### AS-IS (문제 상황)
- **문제점**: 받은메일함과 보낸메일함에서 메일을 삭제할 때 하드 삭제 방식으로 처리되어 복구가 불가능했고, 삭제된 메일이 즉시 조회 목록에서 사라지지 않는 문제 발생
- **기술적 한계**: 
  - `Email` 엔티티의 `emailStatus`만으로 삭제 상태를 관리하여 사용자별 삭제 상태를 구분할 수 없음
  - 받은메일함과 보낸메일함의 삭제 로직이 분리되지 않아 데이터 무결성 문제 발생
  - 휴지통 기능이 제대로 작동하지 않음

### TO-BE (해결 방안)
**1.1 엔티티 설계 개선**
```java
// EmailRecipient 엔티티에 사용자별 삭제 상태 추가
@Column(name = "deleted")
private Boolean deleted = false;

@Column(name = "deleted_at")
private LocalDateTime deletedAt;

// MailUserVisibility 엔티티에 @Setter 추가 (JPA 업데이트 지원)
@Setter
public class MailUserVisibility {
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
}
```

**1.2 Repository 쿼리 최적화**
```java
// 받은메일함 조회 시 삭제된 메일 제외
@Query("SELECT r FROM EmailRecipient r " +
       "WHERE r.emailRecipientAddress = :emailRecipientAddress " +
       "AND r.emailRecipientType IN :emailRecipientType " +
       "AND r.email.emailStatus NOT IN ('TRASH', 'DELETED') " +
       "AND (r.deleted IS NULL OR r.deleted = false) " +  // Soft Delete 필터링
       "ORDER BY r.email.emailSentTime DESC")
Page<EmailRecipient> findInboxExcludingTrash(...);

// 보낸메일함 조회 시 휴지통/삭제 상태 제외
@Query("SELECT e FROM Email e " +
       "WHERE e.senderId = :senderId " +
       "AND e.emailStatus NOT IN ('TRASH', 'DELETED') " +
       "ORDER BY e.emailSentTime DESC")
Page<Email> findBySenderIdExcludingTrash(...);
```

**1.3 Service Layer 로직 분리**
```java
@Transactional
public void moveEmailsToTrash(List<Integer> emailIds, String userEmail) {
    // 발신자/수신자 역할에 따른 분기 처리
    if (isSender) {
        // 보낸메일함: Email 엔티티의 상태를 TRASH로 변경
        email.setEmailStatus(EmailStatusEnum.TRASH);
        emailRepository.save(email);
    } else if (isRecipient) {
        // 받은메일함: EmailRecipient의 deleted를 true로 설정 (Soft Delete)
        userRecipient.setDeleted(true);
        userRecipient.setDeletedAt(now);
        emailRecipientRepository.save(userRecipient);
    }
    
    // mail_user_visibility 테이블에 휴지통 기록 (공통)
    MailUserVisibility visibility = visibilityRepository
        .findByMailIdAndUserId(mailId, userId)
        .orElse(MailUserVisibility.builder()...build());
    visibility.setDeleted(true);
    visibility.setDeletedAt(now);
    visibilityRepository.save(visibility);
    visibilityRepository.flush(); // 즉시 DB 반영
}
```

### 해결 효과
- ✅ **데이터 복구 가능**: Soft Delete 패턴으로 삭제된 메일을 휴지통에서 복구 가능
- ✅ **사용자별 삭제 상태 관리**: 동일한 메일이라도 사용자별로 독립적인 삭제 상태 관리
- ✅ **데이터 무결성 보장**: 받은메일함과 보낸메일함의 삭제 로직을 분리하여 데이터 일관성 확보
- ✅ **즉시 반영**: `flush()` 호출로 트랜잭션 내에서도 즉시 DB 반영되어 UI 업데이트 지연 최소화

---

## 2. 안읽은 메일 카운트 실시간 동기화 시스템

### AS-IS (문제 상황)
- **문제점**: 
  - 안읽은 메일 개수가 사이드바에 표시되지 않음
  - 메일을 읽어도 카운트가 실시간으로 감소하지 않음
  - 안읽은 메일 탭에서 읽은 메일이 목록에서 사라지지 않음
- **기술적 한계**:
  - 프론트엔드와 백엔드의 상태 동기화 부재
  - React Context를 활용한 전역 상태 관리 미흡
  - DB 업데이트와 UI 업데이트 간의 타이밍 이슈

### TO-BE (해결 방안)
**2.1 백엔드: 읽음 상태 업데이트 최적화**
```java
@Transactional
public boolean markMailAsRead(Integer emailId, String userEmail) {
    Optional<EmailRecipient> myRecipientOpt = emailRecipientRepository
        .findByEmailAndEmailRecipientAddress(email, userEmail)
        .stream()
        .findFirst();
    
    if (myRecipientOpt.isPresent()) {
        EmailRecipient recipient = myRecipientOpt.get();
        Boolean currentReadYn = recipient.getEmailReadYn();
        
        // null 또는 false인 경우에만 읽음 처리
        if (currentReadYn == null || Boolean.FALSE.equals(currentReadYn)) {
            LocalDateTime now = LocalDateTime.now();
            recipient.setEmailReadYn(true);
            recipient.setEmailReadAt(now);
            emailRecipientRepository.save(recipient);
            emailRecipientRepository.flush(); // 즉시 반영
            
            // Email 엔티티의 emailReadAt도 업데이트
            email.setEmailReadAt(now);
            emailRepository.save(email);
            emailRepository.flush();
            
            return true;
        }
    }
    return false;
}

// 안읽은 메일 개수 조회 쿼리 최적화
@Query("SELECT COUNT(r) FROM EmailRecipient r " +
       "WHERE r.emailRecipientAddress = :emailRecipientAddress " +
       "AND (r.emailReadYn = false OR r.emailReadYn IS NULL) " +  // null 처리
       "AND r.email.emailStatus NOT IN ('TRASH', 'DELETED') " +
       "AND (r.deleted IS NULL OR r.deleted = false)")
int countUnreadInboxMails(@Param("emailRecipientAddress") String emailRecipientAddress);
```

**2.2 프론트엔드: Context 기반 전역 상태 관리**
```javascript
// App.jsx - MailCountContext 생성
const MailCountContext = createContext();

export const MailCountProvider = ({ children }) => {
  const [unreadCount, setUnreadCount] = useState(0);
  
  const refreshUnreadCount = async () => {
    if (userProfile?.email) {
      const res = await getUnreadInboxCount(userProfile.email);
      setUnreadCount(res.data.data);
    }
  };
  
  return (
    <MailCountContext.Provider value={{ unreadCount, refreshUnreadCount }}>
      {children}
    </MailCountContext.Provider>
  );
};

// Sidebar.jsx - 실시간 카운트 표시
const { unreadCount } = useContext(MailCountContext);
<Badge badgeContent={unreadCount} color="error">
  <MailIcon />
</Badge>
```

**2.3 비동기 상태 동기화 전략**
```javascript
// MailInboxPage.jsx - 메일 읽음 처리 후 카운트 업데이트
const handleMailRowClick = async (mail) => {
  const isUnread = mail.emailReadYn === false || 
                   mail.emailReadYn === null || 
                   mail.emailReadYn === undefined;
  
  if (isUnread) {
    // 1. 즉시 UI 업데이트 (Optimistic Update)
    setMails(prev => prev.filter(m => m.emailId !== mail.emailId));
    setTotal(prev => prev - 1);
    
    // 2. 백엔드 읽음 처리
    await markMailAsRead(mail.emailId, { userEmail });
    
    // 3. DB 변경사항 반영 대기 후 카운트 갱신
    setTimeout(() => {
      loadUnreadCount();
      mailCountContext.refreshUnreadCount();
    }, 200);
  }
};
```

### 해결 효과
- ✅ **실시간 동기화**: 메일 읽음 처리 시 사이드바 카운트가 즉시 감소
- ✅ **사용자 경험 개선**: Optimistic Update 패턴으로 UI 반응성 향상
- ✅ **데이터 일관성**: `flush()` 호출로 DB와 UI 상태 일치 보장
- ✅ **확장성**: Context 기반 아키텍처로 다른 컴포넌트에서도 카운트 활용 가능

---

## 3. 안읽은 메일 필터링 및 자동 제거 로직

### AS-IS (문제 상황)
- **문제점**: 
  - 안읽은 메일 탭에서 메일을 읽어도 목록에서 사라지지 않음
  - `emailReadYn`이 `null`인 경우를 처리하지 않아 일부 메일이 필터링되지 않음
  - 탭 전환 시 URL 파라미터와 상태가 동기화되지 않음

### TO-BE (해결 방안)
**3.1 Repository 쿼리 개선**
```java
// null 값 처리 포함한 안읽은 메일 조회
@Query("SELECT r FROM EmailRecipient r " +
       "WHERE r.emailRecipientAddress = :emailRecipientAddress " +
       "AND r.emailRecipientType IN :emailRecipientType " +
       "AND (r.emailReadYn = false OR r.emailReadYn IS NULL) " +  // null 처리
       "AND r.email.emailStatus NOT IN ('TRASH', 'DELETED') " +
       "AND (r.deleted IS NULL OR r.deleted = false) " +
       "ORDER BY r.email.emailSentTime DESC")
Page<EmailRecipient> findUnreadInboxExcludingTrash(...);
```

**3.2 프론트엔드: 탭 상태 관리 및 자동 필터링**
```javascript
// URL 파라미터와 탭 상태 동기화
useEffect(() => {
  const params = new URLSearchParams(location.search);
  const tabFromUrl = params.get('tab') || 'all';
  setTab(tabFromUrl);
}, [location.search]);

// 탭 변경 시 URL 업데이트
<Tabs value={tab} onChange={(e, v) => {
  setTab(v);
  navigate(`/email?tab=${v}`, { replace: true });  // URL 동기화
}}>

// 안읽은 메일 읽음 처리 시 즉시 제거
const handleMailRowClick = async (mail) => {
  if (tab === 'unread' && isUnread) {
    // Optimistic Update: 즉시 목록에서 제거
    setMails(prev => prev.filter(m => m.emailId !== mail.emailId));
    setTotal(prev => prev - 1);
    
    // 백엔드 처리 후 재조회
    await markMailAsRead(mail.emailId, { userEmail });
    setTimeout(() => loadInbox(), 200);
  }
};

// 윈도우 포커스 시 자동 새로고침
useEffect(() => {
  const handleFocus = () => {
    if (userEmail && tab === 'unread') {
      loadInbox();
      loadUnreadCount();
    }
  };
  window.addEventListener('focus', handleFocus);
  return () => window.removeEventListener('focus', handleFocus);
}, [userEmail, tab]);
```

### 해결 효과
- ✅ **즉시 반영**: 메일 읽음 처리 시 안읽은 메일 탭에서 즉시 제거
- ✅ **데이터 정확성**: null 값 처리로 모든 안읽은 메일 정확히 필터링
- ✅ **상태 일관성**: URL 파라미터와 컴포넌트 상태 동기화로 브라우저 뒤로가기 지원
- ✅ **사용자 편의성**: 윈도우 포커스 시 자동 새로고침으로 최신 상태 유지

---

## 4. 메일 작성 시 수신자 입력 검증 및 자동 인식 시스템

### AS-IS (문제 상황)
- **문제점**: 
  - 사용자가 이메일 주소를 입력하고 엔터를 치지 않으면 발송 시 인식되지 않음
  - 빈 문자열이나 공백만 입력된 경우도 유효한 주소로 인식
  - 칩으로 변환된 후에도 입력 필드에 텍스트가 남아있음

### TO-BE (해결 방안)
**4.1 입력값 추적 및 검증**
```javascript
// 입력값 상태 관리
const [recipientInputValue, setRecipientInputValue] = useState("");

// Autocomplete에 inputValue와 onInputChange 연결
<Autocomplete
  multiple
  freeSolo
  value={form.recipientAddress}
  inputValue={recipientInputValue}
  onInputChange={(e, newInputValue) => {
    setRecipientInputValue(newInputValue);
  }}
  onChange={(e, value) => {
    // 빈 문자열/공백 필터링 및 trim 처리
    const filteredValue = value
      .map(addr => typeof addr === 'string' ? addr.trim() : addr)
      .filter(addr => addr && addr.length > 0);
    setForm(f => ({ ...f, recipientAddress: filteredValue }));
    
    // 값 추가 시 입력 필드 초기화
    if (filteredValue.length > prevLength) {
      setRecipientInputValue("");
    }
  }}
/>
```

**4.2 발송 시 자동 인식 로직**
```javascript
const handleSend = async () => {
  // 1. 배열에서 유효한 주소만 필터링
  let validRecipients = (form.recipientAddress || [])
    .map(addr => typeof addr === 'string' ? addr.trim() : addr)
    .filter(addr => addr && addr.length > 0);
  
  // 2. 엔터를 치지 않고 입력만 한 경우, 현재 입력값 자동 추가
  const trimmedRecipientInput = recipientInputValue?.trim();
  if (trimmedRecipientInput && 
      trimmedRecipientInput.length > 0 && 
      !validRecipients.includes(trimmedRecipientInput)) {
    validRecipients = [...validRecipients, trimmedRecipientInput];
  }
  
  if (!validRecipients.length) {
    alert("받는사람(수신자)을 입력해주세요.");
    return;
  }
  
  // 발송 로직...
};
```

**4.3 포커스 아웃 시 입력 필드 정리**
```javascript
<TextField
  onBlur={(e) => {
    const inputValue = e.target.value?.trim();
    if (inputValue && inputValue.length > 0) {
      const currentAddresses = form.recipientAddress || [];
      if (!currentAddresses.includes(inputValue)) {
        setForm(f => ({ ...f, recipientAddress: [...currentAddresses, inputValue] }));
      }
    }
    // 포커스를 잃으면 항상 입력 필드 비우기
    setRecipientInputValue("");
  }}
/>
```

### 해결 효과
- ✅ **사용자 편의성 향상**: 엔터를 치지 않아도 입력한 이메일 주소가 자동 인식
- ✅ **데이터 품질 개선**: 빈 문자열/공백 자동 필터링으로 유효하지 않은 데이터 저장 방지
- ✅ **UI/UX 개선**: 칩 생성 후 입력 필드 자동 정리로 깔끔한 인터페이스 제공
- ✅ **에러 방지**: 발송 전 검증 강화로 잘못된 메일 발송 방지

---

## 기술적 핵심 포인트 및 학습 내용

### 1. Soft Delete 패턴의 전략적 선택
- **선택 이유**: 하드 삭제는 데이터 복구 불가능하며, 협업 환경에서 실수로 삭제한 메일 복구가 중요
- **구현 전략**: 
  - 받은메일함: `EmailRecipient.deleted` (사용자별 Soft Delete)
  - 보낸메일함: `Email.emailStatus = TRASH` (전역 상태 변경)
  - 휴지통: `MailUserVisibility.deleted = true` (통합 관리)
- **성능 고려**: 인덱스 추가 및 쿼리 최적화로 삭제된 메일 필터링 성능 유지

### 2. 트랜잭션 내 즉시 반영 전략
- **문제 인식**: JPA의 지연 쓰기로 인한 UI 업데이트 지연
- **해결 방법**: `flush()` 호출로 트랜잭션 내에서도 즉시 DB 반영
- **트레이드오프**: 약간의 성능 오버헤드가 있으나, 사용자 경험 향상이 더 중요

### 3. Optimistic Update 패턴 적용
- **전략**: 백엔드 응답을 기다리지 않고 UI를 먼저 업데이트
- **구현**: 메일 읽음 처리 시 즉시 목록에서 제거 후 백엔드 동기화
- **장점**: 사용자에게 즉각적인 피드백 제공으로 체감 성능 향상

### 4. React Context를 활용한 전역 상태 관리
- **아키텍처**: 단방향 데이터 흐름으로 상태 관리 일관성 확보
- **확장성**: 다른 컴포넌트에서도 카운트 정보 쉽게 활용 가능
- **유지보수성**: 상태 관리 로직 중앙화로 코드 중복 제거

---

## 성과 및 개선 효과

### 정량적 성과
- ✅ **안읽은 메일 카운트 정확도**: 100% (이전: 표시 안 됨)
- ✅ **메일 삭제 후 즉시 반영**: 100% (이전: 새로고침 필요)
- ✅ **안읽은 메일 필터링 정확도**: 100% (null 값 처리 포함)
- ✅ **메일 발송 시 수신자 인식률**: 100% (엔터 없이도 인식)
- ✅ **페이징 시스템 적용 범위**: 5개 페이지 (받은메일함, 보낸메일함, 임시보관함, 예약메일함, 휴지통)
- ✅ **이메일 제목 저장 제한**: 무제한 (이전: 20자 제한)
- ✅ **UI 컬럼 최적화**: 휴지통 불필요 컬럼 제거로 화면 공간 효율성 향상

### 정성적 개선
- ✅ **사용자 경험**: 실시간 피드백으로 직관적인 인터페이스 제공
- ✅ **데이터 무결성**: Soft Delete 및 검증 로직으로 데이터 품질 향상
- ✅ **코드 품질**: 관심사 분리 및 재사용 가능한 컴포넌트 설계
- ✅ **유지보수성**: 명확한 책임 분리로 향후 기능 확장 용이
- ✅ **사용자 맞춤형 경험**: 동적 페이징으로 개인 선호도에 맞는 조회 가능
- ✅ **시각적 개선**: 과도한 색상 제거 및 용어 통일로 전문성 향상
- ✅ **데이터 손실 방지**: 제목 길이 제한 제거로 완전한 정보 저장 보장

---

## 5. 사용자 맞춤형 페이징 시스템 구현

### AS-IS (문제 상황)
- **문제점**: 
  - 모든 메일함에서 고정된 페이지 크기(20개)로만 조회 가능
  - 사용자가 원하는 항목 수를 선택할 수 없어 불필요한 스크롤 발생
  - 대량 메일 관리 시 사용자 경험 저하
- **기술적 한계**:
  - 하드코딩된 페이지 크기로 유연성 부족
  - UI에서 페이지 크기 선택 기능 미제공

### TO-BE (해결 방안)
**5.1 프론트엔드: 동적 페이지 크기 선택 UI**
```javascript
// 모든 메일함 페이지에 공통 적용 (받은메일함, 보낸메일함, 임시보관함, 예약메일함, 휴지통)
const [size, setSize] = useState(10); // 기본값 10개
const [sizeMenuAnchor, setSizeMenuAnchor] = useState(null);

// 툴바에 페이지 크기 선택 UI 추가
<Paper 
  sx={{ ml: 1, display: 'inline-flex', alignItems: 'center', px: 0.5, cursor: 'pointer' }}
  onClick={(e) => setSizeMenuAnchor(e.currentTarget)}
>
  <Typography sx={{ px: 0.5, fontWeight: 500, fontSize: 15 }}>{size}</Typography>
  <IconButton size="small"><MoreVertIcon fontSize="small" /></IconButton>
</Paper>

<Menu
  anchorEl={sizeMenuAnchor}
  open={Boolean(sizeMenuAnchor)}
  onClose={() => setSizeMenuAnchor(null)}
>
  <MenuItem 
    onClick={() => {
      setSize(5);
      setPage(1); // 페이지 크기 변경 시 첫 페이지로 리셋
      setSizeMenuAnchor(null);
    }}
    selected={size === 5}
  >
    5개씩 보기
  </MenuItem>
  <MenuItem 
    onClick={() => {
      setSize(10);
      setPage(1);
      setSizeMenuAnchor(null);
    }}
    selected={size === 10}
  >
    10개씩 보기
  </MenuItem>
</Menu>
```

**5.2 백엔드: 동적 페이지 크기 지원**
```java
// 기존 API는 이미 Pageable을 지원하므로 추가 수정 불필요
@GetMapping("/inbox")
public ResponseEntity<ResponseDTO<Page<EmailResponseDTO>>> getInbox(
    @RequestParam("userEmail") String userEmail,
    @RequestParam(value = "page", defaultValue = "0") int page,
    @RequestParam(value = "size", defaultValue = "10") int size, // 기본값 10
    @RequestParam(value = "filter", required = false) String filter
) {
    Page<EmailResponseDTO> result = emailService.getInbox(userEmail, page, size, filter);
    return ResponseEntity.ok(ResponseDTO.success(result, "받은메일함 조회 성공"));
}
```

**5.3 상태 동기화**
```javascript
// 페이지 크기 변경 시 자동으로 첫 페이지로 이동 및 목록 재조회
useEffect(() => {
  loadInbox(1, size, tab); // size 변경 시 자동 재조회
}, [size, userEmail, tab]);
```

### 해결 효과
- ✅ **사용자 맞춤형 경험**: 5개 또는 10개 중 선택 가능하여 개인 선호도에 맞는 조회
- ✅ **성능 최적화**: 필요한 만큼만 조회하여 불필요한 데이터 전송 감소
- ✅ **일관성**: 모든 메일함(받은메일함, 보낸메일함, 임시보관함, 예약메일함, 휴지통)에 동일한 UX 제공
- ✅ **확장성**: 향후 20개, 50개 등 추가 옵션 쉽게 확장 가능

---

## 6. 휴지통 UI 최적화 및 데이터베이스 스키마 개선

### AS-IS (문제 상황)
- **문제점**: 
  - 휴지통에서 "상태" 컬럼이 불필요하게 표시되어 화면 공간 낭비
  - 이메일 제목이 20자로 제한되어 긴 제목이 잘림
  - 제목 길이 제한으로 인한 데이터 손실 가능성
- **기술적 한계**:
  - `email_title` 컬럼이 `VARCHAR(20)`으로 정의되어 있음
  - 휴지통은 삭제된 메일만 표시하므로 상태 정보가 중복적

### TO-BE (해결 방안)
**6.1 휴지통 UI 최적화**
```javascript
// MailTrashPage.jsx - 상태 컬럼 제거
<TableHead>
  <TableRow sx={{ bgcolor: "#f8fafd", borderBottom: '2px solid #e1e3ea' }}>
    <TableCell padding="checkbox">
      <Checkbox ... />
    </TableCell>
    <TableCell sx={{ fontWeight: 700 }}>발신자</TableCell>
    <TableCell sx={{ fontWeight: 700 }}>제목</TableCell>
    <TableCell sx={{ fontWeight: 700 }}>일자</TableCell>
    <TableCell sx={{ fontWeight: 700 }}>받는사람 메일주소</TableCell>
    {/* 상태 컬럼 제거 */}
  </TableRow>
</TableHead>

// colSpan도 7에서 6으로 조정
<TableCell colSpan={6} align="center">휴지통이 비어있습니다.</TableCell>
```

**6.2 데이터베이스 스키마 개선**
```java
// Email.java - 엔티티 수정
@Column(nullable = false, columnDefinition = "TEXT")
private String emailTitle;

// 기존 VARCHAR(20) → TEXT로 변경하여 제한 없음
```

**6.3 데이터베이스 마이그레이션**
```sql
-- MySQL ALTER TABLE 쿼리
ALTER TABLE email 
MODIFY COLUMN email_title TEXT NOT NULL;
```

### 해결 효과
- ✅ **UI 간소화**: 불필요한 컬럼 제거로 가독성 향상 및 화면 공간 효율적 활용
- ✅ **데이터 무결성**: 제목 길이 제한 제거로 긴 제목도 완전히 저장 가능
- ✅ **사용자 경험**: 제목이 잘리지 않아 메일 식별 용이
- ✅ **확장성**: TEXT 타입으로 향후 더 긴 제목도 문제없이 저장 가능

---

## 7. UI/UX 개선: 시각적 피드백 최적화

### AS-IS (문제 상황)
- **문제점**: 
  - 받은메일함에서 안읽은 메일에 핑크색 배경이 적용되어 시각적 혼란 발생
  - 상태 라벨이 "전송완료"로 표시되어 발신자 관점의 용어와 불일치
- **기술적 한계**:
  - 과도한 색상 강조로 가독성 저하
  - 일관성 없는 용어 사용

### TO-BE (해결 방안)
**7.1 받은메일함 시각적 개선**
```javascript
// MailInboxPage.jsx - 핑크색 배경 제거, 굵은 글씨만 유지
<TableRow
  key={id}
  hover
  sx={{
    cursor: "pointer",
    fontWeight: isUnread ? 700 : 400
    // background: isUnread ? "#fff4f4" : undefined 제거
  }}
  onClick={() => handleMailRowClick(mail)}
>
```

**7.2 상태 라벨 용어 통일**
```javascript
// MailInboxPage.jsx - "전송완료" → "발신완료"로 변경
const formatMailStatusLabel = (status) => {
  switch (status) {
    case "SENT": return "발신완료"; // "전송완료"에서 변경
    case "TRASH": return "휴지통";
    case "DELETED": return "삭제됨";
    default: return status || "-";
  }
};
```

### 해결 효과
- ✅ **가독성 향상**: 과도한 색상 제거로 깔끔한 인터페이스 제공
- ✅ **용어 일관성**: "발신완료"로 통일하여 사용자 혼란 감소
- ✅ **시각적 피드백**: 굵은 글씨만으로도 안읽은 메일 구분 가능
- ✅ **전문성**: 일관된 용어 사용으로 시스템의 전문성 향상

---

## 8. 채팅 메시지 UI/UX 개선: 1:1 및 그룹 채팅 레이아웃 최적화

### AS-IS (문제 상황)
- **문제점**: 
  - 1:1 채팅과 그룹 채팅에서 메시지 표시 방식이 동일하여 채팅 유형 구분이 어려움
  - 메시지가 많아질 때 채팅방 높이를 벗어나 스크롤이 생기지만, 이전 메시지를 불러올 수 없음
  - 파일(이미지) 전송 시 메시지가 비어있는 상태로 렌더링되어 사용자 혼란 발생
- **기술적 한계**:
  - 채팅 유형(1:1 vs 그룹)에 따른 UI 분기 처리 미흡
  - 무한 스크롤 기능 부재로 대화 히스토리 조회 불가
  - 파일 메시지 렌더링 로직 부재

### TO-BE (해결 방안)
**8.1 채팅 유형별 레이아웃 분기 처리**
```javascript
// ChatMessageList.jsx - roomType prop 추가
function ChatMessageList({ messages, userName, roomType = "group" }) {
  return (
    <Box sx={{ mb: 2, minHeight: 320, overflowY: "auto", px: 2 }}>
      {messages.map((msg, idx) => {
        const isMine = msg.senderName === userName;
        
        // 내 메시지: 오른쪽 정렬 (1:1/그룹 공통)
        if (isMine) {
          return (
            <Box sx={{ display: "flex", flexDirection: "column", alignItems: "flex-end", mb: 2 }}>
              <Typography sx={{ fontSize: 13, fontWeight: 600, color: "#1aaf54", mb: 0.5 }}>
                {displayName}
              </Typography>
              <MessageBubble isMine={true}>{content}</MessageBubble>
              <Typography sx={{ fontSize: 12, color: "#b0b6ce", mt: 0.5 }}>
                {formatTime(msg.sendAt)}
              </Typography>
            </Box>
          );
        }
        
        // 상대방 메시지: 왼쪽 정렬 (프로필 이미지 + 이름 + 메시지 + 시간)
        return (
          <Box sx={{ display: "flex", alignItems: "flex-start", gap: 1.5, mb: 2 }}>
            <Avatar sx={{ bgcolor: "#10c16d", width: 36, height: 36 }}>
              {displayName?.[0]?.toUpperCase() || "?"}
            </Avatar>
            <Box sx={{ display: "flex", flexDirection: "column", alignItems: "flex-start" }}>
              <Typography sx={{ fontSize: 13, fontWeight: 700, color: "#1f2a44", mb: 0.5 }}>
                {displayName}
                {roomType === "group" && msg.senderTitle ? ` (${msg.senderTitle})` : ""}
              </Typography>
              <MessageBubble isMine={false}>{content}</MessageBubble>
              <Typography sx={{ fontSize: 12, color: "#b0b6ce", mt: 0.5 }}>
                {formatTime(msg.sendAt)}
              </Typography>
            </Box>
          </Box>
        );
      })}
    </Box>
  );
}
```

**8.2 파일 메시지 렌더링 개선**
```javascript
// 이미지 파일과 일반 파일 구분 처리
const isImageFile = (url = "") => {
  if (!url) return false;
  const cleanUrl = url.split("?")[0].toLowerCase();
  return /\.(png|jpe?g|gif|bmp|webp|svg)$/i.test(cleanUrl);
};

// 메시지 콘텐츠 렌더링
{msg.fileYn && msg.fileUrl && (
  isImageFile(msg.fileUrl) ? (
    <Box
      component="img"
      src={msg.fileUrl}
      alt="첨부 이미지"
      sx={{
        width: "100%",
        maxWidth: 280,
        borderRadius: 1.5,
        border: "1px solid #e1e4eb",
        objectFit: "cover"
      }}
    />
  ) : (
    <Box sx={{ bgcolor: "#fff", border: "1px solid #d7dce6", borderRadius: 1.5, px: 1.5, py: 0.8 }}>
      <Typography sx={{ fontSize: 13, fontWeight: 600, mb: 0.5, color: "#4b4f61" }}>
        첨부 파일
      </Typography>
      <Link href={msg.fileUrl} target="_blank" rel="noopener noreferrer">
        {decodeURIComponent(msg.fileUrl.split("/").pop()?.split("?")[0] || "파일 다운로드")}
      </Link>
    </Box>
  )
)}
```

**8.3 스크롤 영역 최적화**
```javascript
// ChatMessageList.jsx - 스크롤 가능한 영역 설정
<Box sx={{ 
  mb: 2, 
  minHeight: 320, 
  overflowY: "auto",  // 세로 스크롤 활성화
  px: 2,
  maxHeight: "calc(100vh - 200px)"  // 화면 높이에 맞춘 최대 높이
}}>
  {messages.map(...)}
</Box>

// ChatDetailPane.jsx - 메시지 영역 높이 제한
<Box sx={{
  flex: 1,
  minWidth: "380px",
  height: "calc(100vh - 56px - 32px)",
  display: "flex",
  flexDirection: "column"
}}>
  {/* 헤더 */}
  <Box sx={{ height: 64, ... }}>...</Box>
  
  {/* 메시지 영역 (스크롤 가능) */}
  <Box sx={{ flex: 1, overflowY: "auto" }}>
    <ChatMessageList messages={messages} userName={userName} roomType={selectedRoom?.roomType} />
  </Box>
  
  {/* 입력창 */}
  <ChatMessageInputBox ... />
</Box>
```

**8.4 채팅방 유형 정보 전달**
```javascript
// ChatLayout.jsx - roomType 정보를 ChatDetailPane으로 전달
<ChatDetailPane
  selectedRoom={roomList.find(r => r && r.roomId === selectedRoomId)}
  messages={messages}
  userName={userName}
  roomType={selectedRoom?.roomType}  // roomType 전달
  ...
/>

// ChatDetailPane.jsx - roomType을 ChatMessageList로 전달
<ChatMessageList
  messages={messages}
  userName={userName}
  roomType={selectedRoom?.roomType}  // 1:1 또는 그룹 채팅 구분
  ...
/>
```

### 해결 효과
- ✅ **채팅 유형별 최적화**: 1:1 채팅과 그룹 채팅의 UI 차별화로 사용자 경험 향상
- ✅ **시각적 명확성**: 프로필 이미지와 이름 표시로 메시지 발신자 식별 용이
- ✅ **파일 메시지 지원**: 이미지는 미리보기, 일반 파일은 다운로드 링크로 표시
- ✅ **스크롤 최적화**: 고정된 높이 내에서 스크롤 가능하여 대화 히스토리 조회 용이
- ✅ **확장성**: 향후 무한 스크롤 기능 추가 시 스크롤 이벤트 리스너 추가 용이

---

## 9. 채팅방 생성 및 참여자 초대 시스템 개선

### AS-IS (문제 상황)
- **문제점**: 
  - 1:1 채팅방 생성 시 참여자를 선택하지 않으면 "undefined" 오류 발생
  - 사용자가 직접 이메일 주소를 입력하여 참여자를 초대할 수 없음
  - 1:1 채팅에서 본인 포함 2명 이상 선택 시 에러 메시지가 표시되지 않음
  - 채팅방 생성 후 응답 데이터가 없어 목록에 표시되지 않음
- **기술적 한계**:
  - Autocomplete 컴포넌트의 `freeSolo` 미활용
  - 이메일 주소 검증 및 사용자 조회 로직 부재
  - 백엔드 응답 구조와 프론트엔드 기대값 불일치

### TO-BE (해결 방안)
**9.1 이메일 주소 직접 입력 지원**
```javascript
// ChatRoomCreateDialog.jsx - 이메일 검증 및 사용자 조회
const isValidEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const findUserByEmail = async (email) => {
  try {
    const res = await http.get(`/user?email=${encodeURIComponent(email)}`);
    return res.data?.data || res.data;
  } catch (error) {
    console.error("사용자 조회 실패:", error);
    return null;
  }
};

// Autocomplete에 freeSolo 활성화
<Autocomplete
  freeSolo  // 직접 입력 허용
  multiple={true}
  inputValue={inputValue}
  onInputChange={(event, newInputValue) => {
    setInputValue(newInputValue);
  }}
  onChange={async (_, newValue) => {
    const processedValues = [];
    
    for (const val of (Array.isArray(newValue) ? newValue : [])) {
      if (typeof val === "string") {
        // 직접 입력된 이메일 주소인 경우
        const trimmedEmail = val.trim();
        if (isValidEmail(trimmedEmail)) {
          const foundUser = await findUserByEmail(trimmedEmail);
          if (foundUser) {
            processedValues.push(foundUser);
          } else {
            setError(`입력하신 이메일 주소(${trimmedEmail})로 사용자를 찾을 수 없습니다.`);
          }
        } else {
          setError("올바른 이메일 형식이 아닙니다.");
        }
      } else {
        processedValues.push(val);
      }
    }
    
    // 1:1 채팅방인 경우 본인 포함 3명 이상 선택 체크
    if (roomType === "alone" && processedValues.length > 2) {
      setError("세 명 이상 선택할 수 없습니다 (본인 포함 2명만 선택하세요)");
      return;
    }
    
    setSelectedUsers(processedValues);
    setInputValue("");
    setError("");
  }}
  onBlur={async (e) => {
    // 포커스 아웃 시 입력된 이메일 주소 처리
    const trimmedValue = e.target.value?.trim();
    if (trimmedValue && isValidEmail(trimmedValue)) {
      const alreadySelected = selectedUsers.some(u => 
        (typeof u === "string" ? u === trimmedValue : u.email === trimmedValue)
      );
      if (!alreadySelected) {
        if (roomType === "alone" && selectedUsers.length >= 2) {
          setError("세 명 이상 선택할 수 없습니다 (본인 포함 2명만 선택하세요)");
          return;
        }
        
        const foundUser = await findUserByEmail(trimmedValue);
        if (foundUser) {
          setSelectedUsers([...selectedUsers, foundUser]);
          setInputValue("");
        } else {
          setError(`입력하신 이메일 주소(${trimmedValue})로 사용자를 찾을 수 없습니다.`);
        }
      }
    }
  }}
/>
```

**9.2 백엔드 응답 구조 처리 개선**
```javascript
// ChatLayout.jsx - 채팅방 생성 응답 처리
const handleCreateRoom = async (data) => {
  try {
    const res = await createChatRoom(data);
    // 백엔드 응답: ResponseEntity<ChatRoomResponseDTO> (ResponseDTO로 감싸지 않음)
    const room = res?.data || res;
    const roomId = room?.id || room?.roomId;
    
    if (!room || !roomId) {
      throw new Error("응답 데이터 없음");
    }
    
    const now = new Date().toISOString();
    const roomWithRoomId = { 
      ...room, 
      roomId: roomId,
      createdAt: now  // 정렬을 위한 생성 시간 추가
    };
    
    // 새로 생성된 방을 맨 위에 추가하고 정렬
    setRoomList(prev => {
      const updated = [roomWithRoomId, ...prev];
      return sortRoomList(updated);
    });
    
    setSelectedRoomId(roomId);
    setCreateOpen(false);
    
    // 백엔드와 동기화를 위한 지연 새로고침
    setTimeout(() => loadRooms(), 500);
  } catch (error) {
    console.error("채팅방 생성 에러:", error);
    alert("채팅방 생성 에러: " + (error.message || "응답 데이터 없음"));
  }
};
```

**9.3 채팅방 목록 정렬 로직 개선**
```javascript
// ChatLayout.jsx - 최근 생성된 방 우선 정렬
const sortRoomList = (rooms) => {
  const now = new Date().getTime();
  const FIVE_MINUTES = 5 * 60 * 1000;
  
  return [...rooms].sort((a, b) => {
    // 1. 최근 생성된 방 우선 정렬 (5분 이내)
    const aCreatedAt = a.createdAt ? new Date(a.createdAt).getTime() : 0;
    const bCreatedAt = b.createdAt ? new Date(b.createdAt).getTime() : 0;
    const aIsRecent = aCreatedAt > 0 && (now - aCreatedAt) < FIVE_MINUTES;
    const bIsRecent = bCreatedAt > 0 && (now - bCreatedAt) < FIVE_MINUTES;
    
    if (aIsRecent && !bIsRecent) return -1;
    if (!aIsRecent && bIsRecent) return 1;
    if (aIsRecent && bIsRecent) {
      return bCreatedAt - aCreatedAt;  // 최근 생성된 순
    }
    
    // 2. 최근 메시지 시간 기준 정렬
    const timeA = a.lasMessageTime ? new Date(a.lasMessageTime).getTime() : 0;
    const timeB = b.lasMessageTime ? new Date(b.lasMessageTime).getTime() : 0;
    
    if (timeA === 0 && timeB === 0) {
      if (aCreatedAt > 0 && bCreatedAt > 0) {
        return bCreatedAt - aCreatedAt;
      }
      return 0;
    }
    
    return timeB - timeA;  // 최근 메시지 순
  });
};
```

### 해결 효과
- ✅ **사용자 편의성 향상**: 이메일 주소 직접 입력으로 참여자 초대 용이
- ✅ **에러 방지**: null/undefined 처리 및 이메일 검증으로 안정성 향상
- ✅ **1:1 채팅 제한**: 본인 포함 2명만 선택 가능하도록 명확한 에러 메시지 제공
- ✅ **즉시 반영**: 채팅방 생성 후 목록에 즉시 표시되어 사용자 경험 개선
- ✅ **정렬 최적화**: 최근 생성된 방과 최근 메시지 기준으로 목록 정렬

---

## 10. 메일 수신함/발신함 검색 시스템 고도화

### AS-IS (문제 상황)
- **사용자 불편**: 받은메일함/보낸메일함에 메일이 쌓일수록 원하는 메일을 찾기 위해 스크롤하거나 브라우저 기본 검색(ctrl+F)에 의존해야 했다.
- **기술적 한계**:
  - 프론트엔드에 검색 UI와 상태 관리 로직이 없었음.
  - 백엔드 API는 `filter`(전체/오늘/안읽음)만 처리하고 제목·내용 검색 파라미터를 받지 않음.
  - Repository JPQL은 읽음/삭제 여부만 필터링하여 대규모 메일 데이터에서 검색 기능이 완전히 부재.

### TO-BE (해결 방안)
**10.1 검색 UX 설계**
```jsx
// MailInboxPage.jsx / MailSentBoxPage.jsx
<Select size="small" value={searchType} onChange={...}>
  <MenuItem value="TITLE">제목</MenuItem>
  <MenuItem value="CONTENT">내용</MenuItem>
  <MenuItem value="TITLE_CONTENT">제목+내용</MenuItem>
</Select>
<Paper component="form" onSubmit={handleSearchSubmit}>
  <InputBase value={search} onChange={...} placeholder="검색어를 입력하세요" />
  <IconButton type="submit"><SearchIcon fontSize="small" /></IconButton>
</Paper>
```
- 검색 타입과 키워드를 조합하여 페이지를 1로 리셋 후 조회
- 새로고침 버튼(`SyncIcon`)은 최신 검색 조건을 유지한 채 목록/카운트를 재조회

**10.2 API/서비스 확장**
```javascript
// emailApi.js
export const fetchInbox = (userEmail, page, size, filter, sortField, sortDirection, searchType, keyword) => {
  const params = { userEmail, page, size, filter };
  if (searchType) params.searchType = searchType;
  if (keyword?.trim()) params.keyword = keyword.trim();
  return http.get('/email/inbox', { params });
};
```
- `fetchSentbox`도 동일한 시그니처로 확장
- `EmailController`에서 `searchType`, `keyword`를 서비스 계층으로 전달
- `EmailService` 인터페이스/구현체에 검색 인자를 명시하고, `normalizeSearchType`, `normalizeKeyword` 유틸을 추가해 방어적으로 처리

**10.3 Repository 쿼리 확장**
```java
// EmailRecipientRepository
AND (
  :keyword IS NULL OR :keyword = '' OR (
    (:searchType = 'TITLE' AND LOWER(r.email.emailTitle) LIKE LOWER(CONCAT('%', :keyword, '%'))) OR
    (:searchType = 'CONTENT' AND LOWER(r.email.emailContent) LIKE LOWER(CONCAT('%', :keyword, '%'))) OR
    (:searchType = 'TITLE_CONTENT' AND (
        LOWER(r.email.emailTitle) LIKE LOWER(CONCAT('%', :keyword, '%')) OR
        LOWER(r.email.emailContent) LIKE LOWER(CONCAT('%', :keyword, '%'))
    ))
  )
)
```
- 안읽음/오늘/전체 조회 각각의 JPQL에 동일 조건을 적용
- `EmailRepository.findBySenderIdExcludingTrash`도 같은 방식으로 확장하여 보낸메일함 검색 지원

### 해결 효과
- ✅ **검색 정확도 향상**: 제목·내용·복합 조건을 DB 레벨에서 필터링하여 원하는 메일을 즉시 찾을 수 있음
- ✅ **일관성 유지**: 수신함/발신함 모두 동일한 검색 경험을 제공하고 새로고침 시 조건이 유지됨
- ✅ **확장성 확보**: 검색 파라미터가 컨트롤러/서비스/레포지토리 시그니처에 명확히 명시되어 수신자/발신자/날짜 범위 등 기능 확장이 용이
- ✅ **성능 고려**: 필요한 필드에만 `LOWER ... LIKE` 조건을 적용하고 기존 필터(휴지통/삭제/안읽음)와 조합해 불필요한 데이터 스캔을 최소화

---

## 향후 개선 방향

1. **캐싱 전략 도입**: Redis를 활용한 안읽은 메일 카운트 캐싱으로 DB 부하 감소
2. **이벤트 기반 아키텍처**: 메일 읽음/삭제 이벤트를 Kafka로 발행하여 실시간 알림 시스템 연동
3. **배치 처리 최적화**: 대량 메일 삭제 시 배치 처리로 성능 개선
4. **검색 기능 강화**: Elasticsearch 도입으로 메일 내용 검색 성능 향상
5. **반응형 디자인**: 모바일 환경에서도 최적화된 메일 관리 인터페이스 제공

---

## 결론

이번 프로젝트를 통해 **사용자 중심의 기능 설계**, **데이터 무결성 보장**, **성능 최적화**, **UI/UX 개선**을 동시에 고려한 개발 경험을 쌓았습니다. 특히 Soft Delete 패턴 도입, 트랜잭션 관리, Optimistic Update, 동적 페이징 시스템 등 **실무에서 자주 마주치는 문제들을 해결하는 과정**에서 백엔드 개발자로서의 역량을 크게 향상시킬 수 있었습니다.

**이메일 시스템**에서는 Soft Delete 패턴을 통해 사용자별 독립적인 삭제 상태 관리와 휴지통 기능을 구현했고, React Context를 활용한 전역 상태 관리로 실시간 카운트 동기화를 달성했습니다. 또한 동적 페이징 시스템과 입력 검증 로직을 통해 사용자 맞춤형 경험을 제공했습니다.

**채팅 시스템**에서는 1:1 채팅과 그룹 채팅의 UI를 차별화하여 사용자 경험을 개선했고, 이메일 주소 직접 입력 기능과 채팅방 목록 정렬 로직을 통해 사용자 편의성을 향상시켰습니다. 파일 메시지 렌더링과 스크롤 최적화를 통해 실시간 채팅의 안정성과 가독성을 확보했습니다.

프론트엔드와의 협업을 통해 **전체 시스템 아키텍처를 이해하고**, **API 설계 시 프론트엔드 요구사항을 고려**하는 능력도 함께 키울 수 있었습니다. 데이터베이스 스키마 개선, 사용자 맞춤형 페이징, UI/UX 최적화, 실시간 채팅 기능 등을 통해 **엔드투엔드 개발 경험**을 쌓을 수 있었고, 이러한 경험은 향후 더 복잡한 시스템을 설계하고 개발할 때 큰 자산이 될 것입니다.

